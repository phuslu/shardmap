// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o wyhash.go github.com/zeebo/wyhash

package shardmap

import (
	"encoding/binary"
	"math/bits"
	"sync"
	"unsafe"
)

type (
	wyhash_ptr  = unsafe.Pointer
	wyhash_uptr = uintptr

	wyhash_u32 = uint32
	wyhash_u64 = uint64
)

const (
	wyhash__wyp0 = 0xa0761d6478bd642f
	wyhash__wyp1 = 0xe7037ed1a0b428db
	wyhash__wyp2 = 0x8ebc6af09c88c6e3
	wyhash__wyp3 = 0x589965cc75374cc3
	wyhash__wyp4 = 0x1d8e4e27c47d124f
)

func wyhash_i(p wyhash_ptr, n wyhash_uptr) wyhash_ptr { return wyhash_ptr(wyhash_uptr(p) + n) }

func wyhash__wymum(A, B wyhash_u64) wyhash_u64 {
	hi, lo := bits.Mul64(A, B)
	return hi ^ lo
}

func wyhash__wyr8(p wyhash_ptr) wyhash_u64 {
	return binary.LittleEndian.Uint64((*[8]byte)(p)[:])
}

func wyhash__wyr4(p wyhash_ptr) wyhash_u64 {
	return wyhash_u64(binary.LittleEndian.Uint32((*[4]byte)(p)[:]))
}

func wyhash__wyr3(p wyhash_ptr, k wyhash_uptr) wyhash_u64 {
	b0 := wyhash_u64(*(*byte)(p))
	b1 := wyhash_u64(*(*byte)(wyhash_i(p, k>>1)))
	b2 := wyhash_u64(*(*byte)(wyhash_i(p, k-1)))
	return b0<<16 | b1<<8 | b2
}

func wyhash__wyr9(p wyhash_ptr) wyhash_u64 {
	b := (*[8]byte)(p)
	return wyhash_u64(wyhash_u32(b[0])|wyhash_u32(b[1])<<8|wyhash_u32(b[2])<<16|wyhash_u32(b[3])<<24)<<32 |
		wyhash_u64(wyhash_u32(b[4])|wyhash_u32(b[5])<<8|wyhash_u32(b[6])<<16|wyhash_u32(b[7])<<24)
}

func wyhash_hash(data string, seed wyhash_u64) wyhash_u64 {
	p, len := *(*wyhash_ptr)(wyhash_ptr(&data)), wyhash_uptr(len(data))
	see1, off := seed, len

	switch {
	case len <= 0x03:
		return wyhash__wymum(wyhash__wymum(wyhash__wyr3(p, len)^seed^wyhash__wyp0, seed^wyhash__wyp1)^seed, wyhash_u64(len)^wyhash__wyp4)

	case len <= 0x08:
		return wyhash__wymum(wyhash__wymum(wyhash__wyr4(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr4(wyhash_i(p, len-0x04))^seed^wyhash__wyp1)^seed, wyhash_u64(len)^wyhash__wyp4)

	case len <= 0x10:
		return wyhash__wymum(wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr9(wyhash_i(p, len-0x08))^seed^wyhash__wyp1)^seed, wyhash_u64(len)^wyhash__wyp4)

	case len <= 0x18:
		return wyhash__wymum(wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr9(wyhash_i(p, 0x08))^seed^wyhash__wyp1)^wyhash__wymum(wyhash__wyr9(wyhash_i(p, len-0x08))^seed^wyhash__wyp2, seed^wyhash__wyp3), wyhash_u64(len)^wyhash__wyp4)

	case len <= 0x20:
		return wyhash__wymum(wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr9(wyhash_i(p, 0x08))^seed^wyhash__wyp1)^wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x10))^seed^wyhash__wyp2, wyhash__wyr9(wyhash_i(p, len-0x08))^seed^wyhash__wyp3), wyhash_u64(len)^wyhash__wyp4)

	case len <= 0x100:
		seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x08))^seed^wyhash__wyp1)
		see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x10))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x18))^see1^wyhash__wyp3)
		if len > 0x40 {
			seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x20))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x28))^seed^wyhash__wyp1)
			see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x30))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x38))^see1^wyhash__wyp3)
			if len > 0x60 {
				seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x40))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x48))^seed^wyhash__wyp1)
				see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x50))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x58))^see1^wyhash__wyp3)
				if len > 0x80 {
					seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x60))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x68))^seed^wyhash__wyp1)
					see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x70))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x78))^see1^wyhash__wyp3)
					if len > 0xa0 {
						seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x80))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x88))^seed^wyhash__wyp1)
						see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x90))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x98))^see1^wyhash__wyp3)
						if len > 0xc0 {
							seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xa0))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0xa8))^seed^wyhash__wyp1)
							see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xb0))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0xb8))^see1^wyhash__wyp3)
							if len > 0xe0 {
								seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xc0))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0xc8))^seed^wyhash__wyp1)
								see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xd0))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0xd8))^see1^wyhash__wyp3)
							}
						}
					}
				}
			}
		}

		off = (off-1)%0x20 + 1
		p = wyhash_i(p, len-off)

	default:
		for ; off > 0x100; off, p = off-0x100, wyhash_i(p, 0x100) {
			seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x08))^seed^wyhash__wyp1) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x10))^seed^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x18))^seed^wyhash__wyp3)
			see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x20))^see1^wyhash__wyp1, wyhash__wyr8(wyhash_i(p, 0x28))^see1^wyhash__wyp2) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x30))^see1^wyhash__wyp3, wyhash__wyr8(wyhash_i(p, 0x38))^see1^wyhash__wyp0)
			seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x40))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x48))^seed^wyhash__wyp1) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x50))^seed^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x58))^seed^wyhash__wyp3)
			see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x60))^see1^wyhash__wyp1, wyhash__wyr8(wyhash_i(p, 0x68))^see1^wyhash__wyp2) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x70))^see1^wyhash__wyp3, wyhash__wyr8(wyhash_i(p, 0x78))^see1^wyhash__wyp0)
			seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x80))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x88))^seed^wyhash__wyp1) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x90))^seed^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x98))^seed^wyhash__wyp3)
			see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xa0))^see1^wyhash__wyp1, wyhash__wyr8(wyhash_i(p, 0xa8))^see1^wyhash__wyp2) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xb0))^see1^wyhash__wyp3, wyhash__wyr8(wyhash_i(p, 0xb8))^see1^wyhash__wyp0)
			seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xc0))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0xc8))^seed^wyhash__wyp1) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xd0))^seed^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0xd8))^seed^wyhash__wyp3)
			see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xe0))^see1^wyhash__wyp1, wyhash__wyr8(wyhash_i(p, 0xe8))^see1^wyhash__wyp2) ^ wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0xf0))^see1^wyhash__wyp3, wyhash__wyr8(wyhash_i(p, 0xf8))^see1^wyhash__wyp0)
		}
		for ; off > 0x20; off, p = off-0x20, wyhash_i(p, 0x20) {
			seed = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr8(wyhash_i(p, 0x08))^seed^wyhash__wyp1)
			see1 = wyhash__wymum(wyhash__wyr8(wyhash_i(p, 0x10))^see1^wyhash__wyp2, wyhash__wyr8(wyhash_i(p, 0x18))^see1^wyhash__wyp3)
		}
	}

	switch {
	case off > 0x18:
		seed = wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr9(wyhash_i(p, 0x08))^seed^wyhash__wyp1)
		see1 = wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x10))^see1^wyhash__wyp2, wyhash__wyr9(wyhash_i(p, off-0x08))^see1^wyhash__wyp3)

	case off > 0x10:
		seed = wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr9(wyhash_i(p, 0x08))^seed^wyhash__wyp1)
		see1 = wyhash__wymum(wyhash__wyr9(wyhash_i(p, off-0x08))^see1^wyhash__wyp2, see1^wyhash__wyp3)

	case off > 0x08:
		seed = wyhash__wymum(wyhash__wyr9(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr9(wyhash_i(p, off-0x08))^seed^wyhash__wyp1)

	case off > 0x03:
		seed = wyhash__wymum(wyhash__wyr4(wyhash_i(p, 0x00))^seed^wyhash__wyp0, wyhash__wyr4(wyhash_i(p, off-0x04))^seed^wyhash__wyp1)

	default:
		seed = wyhash__wymum(wyhash__wyr3(p, off)^seed^wyhash__wyp0, seed^wyhash__wyp1)
	}

	return wyhash__wymum(seed^see1, wyhash_u64(len)^wyhash__wyp4)
}

// Hash returns a 64bit digest of the data with different ones for every seed.
func wyhash_Hash(data []byte, seed uint64) uint64 {
	if len(data) == 0 {
		return seed
	}
	return wyhash_hash(*(*string)(wyhash_ptr(&data)), seed)
}

// HashString returns a 64bit digest of the data with different ones for every seed.
func wyhash_HashString(data string, seed uint64) uint64 {
	if len(data) == 0 {
		return seed
	}
	return wyhash_hash(*(*string)(wyhash_ptr(&data)), seed)
}

// global is a parallel rng for the package functions.
var wyhash_global struct {
	sync.Mutex
	wyhash_RNG
}

// Int returns a random int.
// Safe for concurrent callers.
func wyhash_Int() int {
	wyhash_global.Lock()
	out := wyhash_global.Int()
	wyhash_global.Unlock()
	return out
}

// Intn returns a int uniformly in [0, n).
// Safe for concurrent callers.
func wyhash_Intn(n int) int {
	wyhash_global.Lock()
	out := wyhash_global.Intn(n)
	wyhash_global.Unlock()
	return out
}

// Uint64 returns a random uint64.
// Safe for concurrent callers.
func wyhash_Uint64() uint64 {
	wyhash_global.Lock()
	out := wyhash_global.Uint64()
	wyhash_global.Unlock()
	return out
}

// Uint64n returns a uint64 uniformly in [0, n).
// Safe for concurrent callers.
func wyhash_Uint64n(n uint64) uint64 {
	wyhash_global.Lock()
	out := wyhash_global.Uint64n(n)
	wyhash_global.Unlock()
	return out
}

// Float64 returns a float64 uniformly in [0, 1).
// Safe for concurrent callers.
func wyhash_Float64() float64 {
	wyhash_global.Lock()
	out := wyhash_global.Float64()
	wyhash_global.Unlock()
	return out
}

// RNG is a random number generator.
// The zero value is valid.
type wyhash_RNG uint64

// Int returns a random positive int.
// Not safe for concurrent callers.
func (r *wyhash_RNG) Int() int {
	return int(uint(r.Uint64()) >> 1)
}

// Intn returns an int uniformly in [0, n).
// Not safe for concurrent callers.
func (r *wyhash_RNG) Intn(n int) int {
	if n <= 0 {
		return 0
	}
	return int(r.Uint64n(uint64(n)))
}

// Uint64 returns a random uint64.
// Not safe for concurrent callers.
func (r *wyhash_RNG) Uint64() uint64 {
	*r += wyhash__wyp0
	return wyhash__wymum(wyhash_u64(*r)^wyhash__wyp1, wyhash_u64(*r))
}

// Uint64n returns a uint64 uniformly in [0, n).
// Not safe for concurrent callers.
func (r *wyhash_RNG) Uint64n(n uint64) uint64 {
	if n == 0 {
		return 0
	}

	x := r.Uint64()
	h, l := bits.Mul64(x, n)

	if l < n {
		t := -n
		if t >= n {
			t -= n
			if t >= n {
				t = t % n
			}
		}

	again:
		if l < t {
			x = r.Uint64()
			h, l = bits.Mul64(x, n)
			goto again
		}
	}

	return h
}

// Float64 returns a float64 uniformly in [0, 1).
// Not safe for concurrent callers.
func (r *wyhash_RNG) Float64() (v float64) {
again:
	v = float64(r.Uint64()>>11) / (1 << 53)
	if v == 1 {
		goto again
	}
	return
}
